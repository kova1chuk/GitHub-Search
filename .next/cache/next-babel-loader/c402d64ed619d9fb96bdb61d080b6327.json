{"ast":null,"code":"function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nimport { SET_SEARCH_RESULT } from \"./types\";\nimport { gitApi } from \"utils/api\";\nconst Actions = {\n  setSearchResult: searchResult => {\n    return {\n      type: SET_SEARCH_RESULT,\n      payload: searchResult\n    };\n  },\n  fetchSearch: searchQuery => async dispatch => {\n    try {\n      const repos = await gitApi.searchRepository(searchQuery);\n      let {\n        items,\n        total_count\n      } = repos;\n      items = parseRepos(items);\n      items = await addTopics(items);\n      items = await addIssuesNeedHelp(items);\n      dispatch(Actions.setSearchResult({\n        total_count,\n        repos: items\n      }));\n    } catch (err) {\n      console.log(err);\n    }\n  }\n};\nexport default Actions;\n\nconst parseRepos = repos => {\n  return repos.map(item => {\n    const {\n      name,\n      full_name,\n      owner,\n      html_url,\n      description,\n      stargazers_count,\n      language,\n      license,\n      updated_at\n    } = item;\n    return {\n      name,\n      full_name,\n      owner: owner.login,\n      html_url,\n      description,\n      stargazers_count,\n      language,\n      license: license ? license.name : null,\n      updated_at\n    };\n  });\n};\n\nconst addTopics = repos => {\n  return Promise.all(repos.map(async item => {\n    try {\n      const topics = await gitApi.getRepositoryTopics(item.owner, item.name);\n      return _objectSpread({\n        topics: topics ? topics.names : null\n      }, item);\n    } catch (error) {\n      return item;\n    }\n  }));\n};\n\nconst addIssuesNeedHelp = repos => {\n  return Promise.all(repos.map(async item => {\n    try {\n      const issues = await gitApi.getRepositoryIssuesNeedHelp(item.owner, item.name);\n      return _objectSpread({\n        issues_need_help: issues.length\n      }, item);\n    } catch {\n      return item;\n    }\n  }));\n};","map":{"version":3,"sources":["/home/oleksii/Documents/Programming/BetterMeTest/store/repoSearch/actions.ts"],"names":["SET_SEARCH_RESULT","gitApi","Actions","setSearchResult","searchResult","type","payload","fetchSearch","searchQuery","dispatch","repos","searchRepository","items","total_count","parseRepos","addTopics","addIssuesNeedHelp","err","console","log","map","item","name","full_name","owner","html_url","description","stargazers_count","language","license","updated_at","login","Promise","all","topics","getRepositoryTopics","names","error","issues","getRepositoryIssuesNeedHelp","issues_need_help","length"],"mappings":";;;;;;AAAA,SAASA,iBAAT,QAAsD,SAAtD;AAEA,SAASC,MAAT,QAAuB,WAAvB;AAEA,MAAMC,OAAO,GAAG;AACdC,EAAAA,eAAe,EAAGC,YAAD,IAAsC;AACrD,WAAO;AACLC,MAAAA,IAAI,EAAEL,iBADD;AAELM,MAAAA,OAAO,EAAEF;AAFJ,KAAP;AAID,GANa;AAOdG,EAAAA,WAAW,EAAGC,WAAD,IAAoC,MAAOC,QAAP,IAAoB;AACnE,QAAI;AACF,YAAMC,KAAK,GAAG,MAAMT,MAAM,CAACU,gBAAP,CAAwBH,WAAxB,CAApB;AACA,UAAI;AAAEI,QAAAA,KAAF;AAASC,QAAAA;AAAT,UAAyBH,KAA7B;AAEAE,MAAAA,KAAK,GAAGE,UAAU,CAACF,KAAD,CAAlB;AACAA,MAAAA,KAAK,GAAG,MAAMG,SAAS,CAACH,KAAD,CAAvB;AACAA,MAAAA,KAAK,GAAG,MAAMI,iBAAiB,CAACJ,KAAD,CAA/B;AAEAH,MAAAA,QAAQ,CAACP,OAAO,CAACC,eAAR,CAAwB;AAAEU,QAAAA,WAAF;AAAeH,QAAAA,KAAK,EAAEE;AAAtB,OAAxB,CAAD,CAAR;AACD,KATD,CASE,OAAOK,GAAP,EAAY;AACZC,MAAAA,OAAO,CAACC,GAAR,CAAYF,GAAZ;AACD;AACF;AApBa,CAAhB;AAuBA,eAAef,OAAf;;AAEA,MAAMY,UAAU,GAAIJ,KAAD,IAAW;AAC5B,SAAOA,KAAK,CAACU,GAAN,CAAWC,IAAD,IAAU;AACzB,UAAM;AACJC,MAAAA,IADI;AAEJC,MAAAA,SAFI;AAGJC,MAAAA,KAHI;AAIJC,MAAAA,QAJI;AAKJC,MAAAA,WALI;AAMJC,MAAAA,gBANI;AAOJC,MAAAA,QAPI;AAQJC,MAAAA,OARI;AASJC,MAAAA;AATI,QAUFT,IAVJ;AAYA,WAAO;AACLC,MAAAA,IADK;AAELC,MAAAA,SAFK;AAGLC,MAAAA,KAAK,EAAEA,KAAK,CAACO,KAHR;AAILN,MAAAA,QAJK;AAKLC,MAAAA,WALK;AAMLC,MAAAA,gBANK;AAOLC,MAAAA,QAPK;AAQLC,MAAAA,OAAO,EAAEA,OAAO,GAAGA,OAAO,CAACP,IAAX,GAAkB,IAR7B;AASLQ,MAAAA;AATK,KAAP;AAWD,GAxBM,CAAP;AAyBD,CA1BD;;AA4BA,MAAMf,SAAS,GAAIL,KAAD,IAAW;AAC3B,SAAOsB,OAAO,CAACC,GAAR,CACLvB,KAAK,CAACU,GAAN,CAAU,MAAOC,IAAP,IAAgB;AACxB,QAAI;AACF,YAAMa,MAAM,GAAG,MAAMjC,MAAM,CAACkC,mBAAP,CAA2Bd,IAAI,CAACG,KAAhC,EAAuCH,IAAI,CAACC,IAA5C,CAArB;AACA;AACEY,QAAAA,MAAM,EAAEA,MAAM,GAAGA,MAAM,CAACE,KAAV,GAAkB;AADlC,SAEKf,IAFL;AAID,KAND,CAME,OAAOgB,KAAP,EAAc;AACd,aAAOhB,IAAP;AACD;AACF,GAVD,CADK,CAAP;AAaD,CAdD;;AAgBA,MAAML,iBAAiB,GAAIN,KAAD,IAAW;AACnC,SAAOsB,OAAO,CAACC,GAAR,CACLvB,KAAK,CAACU,GAAN,CAAU,MAAOC,IAAP,IAAgB;AACxB,QAAI;AACF,YAAMiB,MAAM,GAAG,MAAMrC,MAAM,CAACsC,2BAAP,CACnBlB,IAAI,CAACG,KADc,EAEnBH,IAAI,CAACC,IAFc,CAArB;AAIA;AACEkB,QAAAA,gBAAgB,EAAEF,MAAM,CAACG;AAD3B,SAEKpB,IAFL;AAID,KATD,CASE,MAAM;AACN,aAAOA,IAAP;AACD;AACF,GAbD,CADK,CAAP;AAgBD,CAjBD","sourcesContent":["import { SET_SEARCH_RESULT, ISearchResultState } from \"./types\";\nimport { ISearchRepository } from \"interfaces\";\nimport { gitApi } from \"utils/api\";\n\nconst Actions = {\n  setSearchResult: (searchResult: ISearchResultState) => {\n    return {\n      type: SET_SEARCH_RESULT,\n      payload: searchResult,\n    };\n  },\n  fetchSearch: (searchQuery: ISearchRepository) => async (dispatch) => {\n    try {\n      const repos = await gitApi.searchRepository(searchQuery);\n      let { items, total_count } = repos;\n\n      items = parseRepos(items);\n      items = await addTopics(items);\n      items = await addIssuesNeedHelp(items);\n\n      dispatch(Actions.setSearchResult({ total_count, repos: items }));\n    } catch (err) {\n      console.log(err);\n    }\n  },\n};\n\nexport default Actions;\n\nconst parseRepos = (repos) => {\n  return repos.map((item) => {\n    const {\n      name,\n      full_name,\n      owner,\n      html_url,\n      description,\n      stargazers_count,\n      language,\n      license,\n      updated_at,\n    } = item;\n\n    return {\n      name,\n      full_name,\n      owner: owner.login,\n      html_url,\n      description,\n      stargazers_count,\n      language,\n      license: license ? license.name : null,\n      updated_at,\n    };\n  });\n};\n\nconst addTopics = (repos) => {\n  return Promise.all(\n    repos.map(async (item) => {\n      try {\n        const topics = await gitApi.getRepositoryTopics(item.owner, item.name);\n        return {\n          topics: topics ? topics.names : null,\n          ...item,\n        };\n      } catch (error) {\n        return item;\n      }\n    })\n  );\n};\n\nconst addIssuesNeedHelp = (repos) => {\n  return Promise.all(\n    repos.map(async (item) => {\n      try {\n        const issues = await gitApi.getRepositoryIssuesNeedHelp(\n          item.owner,\n          item.name\n        );\n        return {\n          issues_need_help: issues.length,\n          ...item,\n        };\n      } catch {\n        return item;\n      }\n    })\n  );\n};\n"]},"metadata":{},"sourceType":"module"}